# Vue3 前端与 Spring Boot 后端接口对接文档

## 📋 目录
1. [接口列表与参数](#接口列表与参数)
2. [前端 Axios 配置](#前端-axios-配置)
3. [状态管理 (Pinia)](#状态管理-pinia)
4. [跨域处理](#跨域处理)
5. [错误处理](#错误处理)
6. [数据流转](#数据流转)
7. [最佳实践](#最佳实践)

## 1. 接口列表与参数

### 1.1 睡眠数据接口

#### GET /api/sleep/data
**功能**: 获取指定用户和日期的睡眠数据

**请求参数**:
```javascript
{
  userId: string,      // 用户ID，必填
  dateOfSleep: string  // 睡眠日期，格式：YYYY-MM-DD，必填
}
```

**响应格式**:
```javascript
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "id": 1,
    "userId": "user001",
    "dateOfSleep": "2024-01-01",
    "totalSleepDuration": 480,    // 总睡眠时长（分钟）
    "deepSleepDuration": 90,      // 深睡时长（分钟）
    "remSleepDuration": 120,      // REM睡眠时长（分钟）
    "sleepScore": 85,             // 睡眠评分
    "processedAt": "2024-01-01T08:00:00"
  }
}
```

**前端调用示例**:
```javascript
// API层
export const sleepApi = {
  getSleepData(userId, dateOfSleep) {
    return request.get('/sleep/data', {
      params: { userId, dateOfSleep }
    })
  }
}

// Store层
const fetchSleepData = async (userId, dateOfSleep) => {
  try {
    loading.value = true
    const response = await sleepApi.getSleepData(userId, dateOfSleep)
    sleepData.value = response.data
    return response.data
  } catch (err) {
    error.value = err.message
    throw err
  } finally {
    loading.value = false
  }
}
```

### 1.2 积分查询接口

#### GET /api/points/current
**功能**: 获取用户当前总积分

**请求参数**:
```javascript
{
  userId: string  // 用户ID，必填
}
```

**响应格式**:
```javascript
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "userId": "user001",
    "totalPoints": 150,           // 总积分
    "todayPoints": 20,            // 今日积分
    "lastUpdated": "2024-01-01T08:00:00"
  }
}
```

**前端调用示例**:
```javascript
// API层
export const pointsApi = {
  getCurrentPoints(userId) {
    return request.get('/points/current', {
      params: { userId }
    })
  }
}

// Store层
const fetchCurrentPoints = async (userId) => {
  try {
    const response = await pointsApi.getCurrentPoints(userId)
    currentPoints.value = response.data
    return response.data
  } catch (err) {
    error.value = err.message
    throw err
  }
}
```

### 1.3 AI 对话接口

#### POST /api/ai/chat
**功能**: 与AI进行多轮对话

**请求参数**:
```javascript
{
  userId: string,    // 用户ID，必填
  message: string    // 用户消息，必填
}
```

**响应格式**:
```javascript
{
  "code": 200,
  "message": "AI回复生成成功",
  "data": "根据您的睡眠问题，我建议您保持规律的作息时间..."
}
```

**前端调用示例**:
```javascript
// API层
export const aiApi = {
  chatWithAI(userId, message) {
    return request.post('/ai/chat', {
      userId,
      message
    })
  }
}

// Store层
const sendChatMessage = async (userId, message) => {
  try {
    isChatting.value = true
    
    // 添加用户消息到聊天记录
    chatMessages.value.push({
      type: 'user',
      content: message,
      timestamp: new Date()
    })
    
    const response = await aiApi.chatWithAI(userId, message)
    const aiResponse = response.data
    
    // 添加AI回复到聊天记录
    chatMessages.value.push({
      type: 'ai',
      content: aiResponse,
      timestamp: new Date()
    })
    
    return aiResponse
  } catch (err) {
    error.value = err.message
    throw err
  } finally {
    isChatting.value = false
  }
}
```

### 1.4 AI 报告生成接口

#### POST /api/ai/report
**功能**: 基于睡眠数据生成AI分析报告

**请求参数**:
```javascript
{
  userId: string,        // 用户ID，必填
  dateOfSleep: string    // 睡眠日期，格式：YYYY-MM-DD，必填
}
```

**响应格式**:
```javascript
{
  "code": 200,
  "message": "AI睡眠报告生成成功",
  "data": "【睡眠分析报告】\n\n【优势】\n您的睡眠质量整体良好...\n\n【不足】\n总睡眠时长略长...\n\n【建议】\n1. 适当缩短睡眠时间..."
}
```

**前端调用示例**:
```javascript
// API层
export const aiApi = {
  generateSleepReport(userId, dateOfSleep) {
    return request.post('/ai/report', {
      userId,
      dateOfSleep
    })
  }
}

// Store层
const generateSleepReport = async (userId, dateOfSleep) => {
  try {
    isGeneratingReport.value = true
    const response = await aiApi.generateSleepReport(userId, dateOfSleep)
    aiReport.value = response.data
    return response.data
  } catch (err) {
    error.value = err.message
    throw err
  } finally {
    isGeneratingReport.value = false
  }
}
```

## 2. 前端 Axios 配置

### 2.1 基础配置

```javascript
// src/utils/request.js
import axios from 'axios'
import { ElMessage } from 'element-plus'

// 创建axios实例
const request = axios.create({
  baseURL: '/api',                    // 基础路径
  timeout: 10000,                     // 请求超时时间
  headers: {
    'Content-Type': 'application/json', // 默认请求头
  },
})

export default request
```

### 2.2 请求拦截器

```javascript
// 请求拦截器
request.interceptors.request.use(
  (config) => {
    // 在发送请求之前做些什么
    console.log('发送请求:', config.url)
    
    // 可以在这里添加认证token
    // const token = localStorage.getItem('token')
    // if (token) {
    //   config.headers.Authorization = `Bearer ${token}`
    // }
    
    return config
  },
  (error) => {
    console.error('请求错误:', error)
    return Promise.reject(error)
  }
)
```

### 2.3 响应拦截器

```javascript
// 响应拦截器
request.interceptors.response.use(
  (response) => {
    const { data } = response
    
    // 统一处理响应格式
    if (data.code === 200) {
      return data
    } else {
      ElMessage.error(data.message || '请求失败')
      return Promise.reject(new Error(data.message || '请求失败'))
    }
  },
  (error) => {
    console.error('响应错误:', error)
    
    let message = '网络错误'
    if (error.response) {
      switch (error.response.status) {
        case 400:
          message = '请求参数错误'
          break
        case 401:
          message = '未授权，请重新登录'
          break
        case 403:
          message = '拒绝访问'
          break
        case 404:
          message = '请求资源不存在'
          break
        case 500:
          message = '服务器内部错误'
          break
        default:
          message = `连接错误${error.response.status}`
      }
    } else if (error.code === 'ECONNABORTED') {
      message = '请求超时'
    }
    
    ElMessage.error(message)
    return Promise.reject(error)
  }
)
```

## 3. 状态管理 (Pinia)

### 3.1 睡眠数据状态管理

```javascript
// src/stores/sleep.js
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { sleepApi } from '@/api/sleep'

export const useSleepStore = defineStore('sleep', () => {
  // 状态
  const sleepData = ref(null)
  const sleepHistory = ref([])
  const loading = ref(false)
  const error = ref(null)

  // 计算属性
  const hasSleepData = computed(() => sleepData.value !== null)
  const sleepScore = computed(() => sleepData.value?.sleepScore || 0)
  const totalSleepDuration = computed(() => sleepData.value?.totalSleepDuration || 0)
  const deepSleepDuration = computed(() => sleepData.value?.deepSleepDuration || 0)
  const deepSleepPercentage = computed(() => {
    if (totalSleepDuration.value === 0) return 0
    return Math.round((deepSleepDuration.value / totalSleepDuration.value) * 100)
  })

  // 动作
  const fetchSleepData = async (userId, dateOfSleep) => {
    try {
      loading.value = true
      error.value = null
      const response = await sleepApi.getSleepData(userId, dateOfSleep)
      sleepData.value = response.data
      return response.data
    } catch (err) {
      error.value = err.message
      throw err
    } finally {
      loading.value = false
    }
  }

  const clearData = () => {
    sleepData.value = null
    sleepHistory.value = []
    error.value = null
  }

  return {
    // 状态
    sleepData,
    sleepHistory,
    loading,
    error,
    // 计算属性
    hasSleepData,
    sleepScore,
    totalSleepDuration,
    deepSleepDuration,
    deepSleepPercentage,
    // 方法
    fetchSleepData,
    clearData,
  }
})
```

### 3.2 积分状态管理

```javascript
// src/stores/points.js
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { pointsApi } from '@/api/points'

export const usePointsStore = defineStore('points', () => {
  // 状态
  const currentPoints = ref(0)
  const pointsHistory = ref([])
  const loading = ref(false)
  const error = ref(null)

  // 计算属性
  const hasPoints = computed(() => currentPoints.value > 0)
  const pointsLevel = computed(() => {
    if (currentPoints.value >= 1000) return { level: '钻石', color: 'text-blue-600' }
    if (currentPoints.value >= 500) return { level: '黄金', color: 'text-yellow-600' }
    if (currentPoints.value >= 200) return { level: '白银', color: 'text-gray-600' }
    return { level: '青铜', color: 'text-orange-600' }
  })

  // 动作
  const fetchCurrentPoints = async (userId) => {
    try {
      loading.value = true
      error.value = null
      const response = await pointsApi.getCurrentPoints(userId)
      currentPoints.value = response.data.totalPoints
      return response.data
    } catch (err) {
      error.value = err.message
      throw err
    } finally {
      loading.value = false
    }
  }

  const clearData = () => {
    currentPoints.value = 0
    pointsHistory.value = []
    error.value = null
  }

  return {
    // 状态
    currentPoints,
    pointsHistory,
    loading,
    error,
    // 计算属性
    hasPoints,
    pointsLevel,
    // 方法
    fetchCurrentPoints,
    clearData,
  }
})
```

### 3.3 AI 对话状态管理

```javascript
// src/stores/ai.js
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import { aiApi } from '@/api/ai'

export const useAIStore = defineStore('ai', () => {
  // 状态
  const aiReport = ref('')
  const chatMessages = ref([])
  const isGeneratingReport = ref(false)
  const isChatting = ref(false)
  const error = ref(null)

  // 计算属性
  const hasAIReport = computed(() => aiReport.value !== '')
  const hasChatMessages = computed(() => chatMessages.value.length > 0)
  const lastChatMessage = computed(() => {
    return chatMessages.value.length > 0 
      ? chatMessages.value[chatMessages.value.length - 1] 
      : null
  })

  // 动作
  const generateSleepReport = async (userId, dateOfSleep) => {
    try {
      isGeneratingReport.value = true
      error.value = null
      const response = await aiApi.generateSleepReport(userId, dateOfSleep)
      aiReport.value = response.data
      return response.data
    } catch (err) {
      error.value = err.message
      throw err
    } finally {
      isGeneratingReport.value = false
    }
  }

  const sendChatMessage = async (userId, message) => {
    try {
      isChatting.value = true
      error.value = null
      
      // 添加用户消息
      chatMessages.value.push({
        type: 'user',
        content: message,
        timestamp: new Date()
      })
      
      const response = await aiApi.chatWithAI(userId, message)
      const aiResponse = response.data
      
      // 添加AI回复
      chatMessages.value.push({
        type: 'ai',
        content: aiResponse,
        timestamp: new Date()
      })
      
      return aiResponse
    } catch (err) {
      error.value = err.message
      throw err
    } finally {
      isChatting.value = false
    }
  }

  const clearChatHistory = async (userId) => {
    try {
      await aiApi.clearChatHistory(userId)
      chatMessages.value = []
      return true
    } catch (err) {
      error.value = err.message
      throw err
    }
  }

  const clearData = () => {
    aiReport.value = ''
    chatMessages.value = []
    error.value = null
  }

  return {
    // 状态
    aiReport,
    chatMessages,
    isGeneratingReport,
    isChatting,
    error,
    // 计算属性
    hasAIReport,
    hasChatMessages,
    lastChatMessage,
    // 方法
    generateSleepReport,
    sendChatMessage,
    clearChatHistory,
    clearData,
  }
})
```

### 3.4 用户状态管理

```javascript
// src/stores/user.js
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const useUserStore = defineStore('user', () => {
  // 状态
  const currentUser = ref({
    userId: 'user001',
    username: '睡眠用户',
    avatar: null,
    lastLoginTime: null
  })
  const isLoggedIn = ref(true)

  // 计算属性
  const userDisplayName = computed(() => 
    currentUser.value.username || currentUser.value.userId
  )

  // 动作
  const setCurrentUser = (user) => {
    currentUser.value = { ...currentUser.value, ...user }
  }

  const logout = () => {
    currentUser.value = {
      userId: '',
      username: '',
      avatar: null,
      lastLoginTime: null
    }
    isLoggedIn.value = false
  }

  const login = (user) => {
    setCurrentUser(user)
    isLoggedIn.value = true
  }

  return {
    // 状态
    currentUser,
    isLoggedIn,
    // 计算属性
    userDisplayName,
    // 方法
    setCurrentUser,
    logout,
    login,
  }
})
```

## 4. 跨域处理

### 4.1 Spring Boot 后端 CORS 配置

```java
// 在控制器类上添加注解
@CrossOrigin(origins = "*")
@RestController
@RequestMapping("/api")
public class SleepAnalysisSummaryController {
    // 控制器代码
}

// 或者全局配置
@Configuration
public class CorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.addAllowedOriginPattern("*");
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        config.setAllowCredentials(true);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        
        return new CorsFilter(source);
    }
}
```

### 4.2 前端代理配置

```javascript
// vite.config.js
export default defineConfig({
  plugins: [vue()],
  server: {
    proxy: {
      '/api': {
        target: 'http://localhost:8080',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, '/api')
      }
    }
  }
})
```

## 5. 错误处理

### 5.1 统一错误处理

```javascript
// src/utils/errorHandler.js
export class ErrorHandler {
  static handle(error) {
    console.error('Error:', error)
    
    if (error.response) {
      // 服务器响应错误
      const { status, data } = error.response
      switch (status) {
        case 400:
          return '请求参数错误'
        case 401:
          return '未授权，请重新登录'
        case 403:
          return '拒绝访问'
        case 404:
          return '请求资源不存在'
        case 500:
          return '服务器内部错误'
        default:
          return data?.message || `请求失败 (${status})`
      }
    } else if (error.request) {
      // 网络错误
      return '网络连接失败，请检查网络'
    } else {
      // 其他错误
      return error.message || '未知错误'
    }
  }
}
```

### 5.2 组件级错误处理

```vue
<template>
  <div>
    <!-- 组件内容 -->
    <div v-if="error" class="error-message">
      {{ error }}
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { useSleepStore } from '@/stores/sleep'

const sleepStore = useSleepStore()
const error = ref(null)

const handleError = (err) => {
  error.value = ErrorHandler.handle(err)
  setTimeout(() => {
    error.value = null
  }, 5000)
}
</script>
```

## 6. 数据流转

### 6.1 数据流向图

```
用户操作 → 组件 → Store → API → 后端接口 → 数据库
    ↓
响应数据 ← 组件 ← Store ← API ← 后端接口 ← 数据库
```

### 6.2 具体流程示例

```javascript
// 1. 用户在组件中触发操作
const handleRefresh = async () => {
  try {
    // 2. 调用Store方法
    await sleepStore.fetchSleepData(userId.value, dateOfSleep.value)
    
    // 3. Store内部调用API
    const response = await sleepApi.getSleepData(userId, dateOfSleep)
    
    // 4. API发送HTTP请求到后端
    // GET /api/sleep/data?userId=user001&date=2024-01-01
    
    // 5. 后端处理请求并返回数据
    // 6. 前端接收响应并更新状态
    sleepData.value = response.data
    
    // 7. 组件响应式更新UI
  } catch (error) {
    // 8. 错误处理
    handleError(error)
  }
}
```

## 7. 最佳实践

### 7.1 API 设计原则

1. **统一响应格式**:
   ```javascript
   {
     "code": 200,
     "message": "操作成功",
     "data": {}
   }
   ```

2. **RESTful 设计**:
   - GET: 查询数据
   - POST: 创建数据
   - PUT: 更新数据
   - DELETE: 删除数据

3. **参数验证**:
   - 前端参数校验
   - 后端参数校验
   - 统一错误处理

### 7.2 状态管理最佳实践

1. **单一数据源**:
   - 每个数据只在一个Store中管理
   - 避免数据重复和同步问题

2. **响应式更新**:
   - 使用computed属性处理衍生数据
   - 保持数据的一致性和实时性

3. **错误边界**:
   - 在Store层统一处理错误
   - 提供友好的错误提示

### 7.3 性能优化

1. **请求缓存**:
   ```javascript
   const cache = new Map()
   
   const fetchData = async (key) => {
     if (cache.has(key)) {
       return cache.get(key)
     }
     
     const data = await api.getData(key)
     cache.set(key, data)
     return data
   }
   ```

2. **防抖处理**:
   ```javascript
   import { debounce } from 'lodash-es'
   
   const debouncedSearch = debounce(async (query) => {
     await searchApi.search(query)
   }, 300)
   ```

3. **加载状态管理**:
   ```javascript
   const loading = ref(false)
   
   const fetchData = async () => {
     if (loading.value) return // 防止重复请求
     
     loading.value = true
     try {
       await api.getData()
     } finally {
       loading.value = false
     }
   }
   ```

### 7.4 代码组织

1. **API层**:
   - 按功能模块分组
   - 统一错误处理
   - 参数类型定义

2. **Store层**:
   - 单一职责原则
   - 状态和动作分离
   - 计算属性优化

3. **组件层**:
   - 最小化状态
   - 事件驱动
   - 可复用性

## 8. 调试技巧

### 8.1 网络请求调试

```javascript
// 在request.js中添加调试信息
request.interceptors.request.use((config) => {
  console.log('🚀 请求:', {
    url: config.url,
    method: config.method,
    params: config.params,
    data: config.data
  })
  return config
})

request.interceptors.response.use((response) => {
  console.log('✅ 响应:', {
    url: response.config.url,
    status: response.status,
    data: response.data
  })
  return response
})
```

### 8.2 Store状态调试

```javascript
// 在Store中添加调试方法
const debugState = () => {
  console.log('🔍 Store状态:', {
    sleepData: sleepData.value,
    loading: loading.value,
    error: error.value
  })
}

// 在组件中调用
const sleepStore = useSleepStore()
sleepStore.debugState()
```

### 8.3 错误追踪

```javascript
// 全局错误处理
window.addEventListener('unhandledrejection', (event) => {
  console.error('未处理的Promise拒绝:', event.reason)
  // 可以发送到错误监控服务
})

// Vue错误处理
app.config.errorHandler = (err, instance, info) => {
  console.error('Vue错误:', err, info)
  // 可以发送到错误监控服务
}
```

## 总结

通过以上配置，Vue3前端与Spring Boot后端可以实现：

1. **无缝对接**: 统一的API接口和响应格式
2. **状态管理**: Pinia提供响应式状态管理
3. **错误处理**: 完善的错误处理和用户提示
4. **性能优化**: 请求缓存、防抖、加载状态管理
5. **开发体验**: 类型安全、调试友好、代码组织清晰

这套架构可以支持复杂的睡眠健康管理应用，提供良好的用户体验和开发体验。
